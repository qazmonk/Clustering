(defpackage :com.chodosh.clustering
  (:use :common-lisp :opticl))
(in-package :com.chodosh.clustering)
(defun randomize (l)
  (let* ((ranked (mapcar (lambda (x) (cons (random 1.0) x)) l))
         (ranked-sorted (sort ranked (lambda (x y) (< (car x) (car y))))))
    (mapcar #'cdr ranked-sorted)))


(defun p-euclidian (x y)
  (do ((x-rest x (rest x-rest))
       (y-rest y (rest y-rest))
       (sum 0)) ((or (null x-rest) (null y-rest)) sum)
    (incf sum (expt (- (first x-rest) (first y-rest)) 2))))
(defun farthest-first (S p k)
  (let ((Y (list (car S)))
        (R ())
        (inserted (make-array (length S) :initial-element nil)))
    (do () ((>= (length Y) k) (values (reverse Y) (reverse R)))
      (do ((s-rest (cdr S) (cdr s-rest))
           (i 0 (1+ i))
           (max (car S))
           (max-val 0)
           (max-idx 0)) ((null s-rest) (progn 
                                         (setf Y (cons max Y))
                                         (setf R (cons max-val R))
                                         (setf (elt inserted max-idx) t)))
        (when (not (elt inserted i))
          (do ((min-val nil)
               (y-rest Y (cdr y-rest))) ((null y-rest) (progn
                                                         (when (> min-val max-val)
                                                           (setf max-val min-val)
                                                           (setf max (car s-rest))
                                                           (setf max-idx i))))
            (when (or (not min-val) (< (funcall p (car s-rest) (car y-rest)) min-val))
              (setf min-val (funcall p (car s-rest) (car y-rest))))))))))

(defun nearest-neighbor (x S p)
  (do ((s-rest S (cdr s-rest))
       (min (car S))
       (idx 0 (1+ idx))
       (min-idx 0)) ((null s-rest) (values min min-idx))
    (when (< (funcall p (car s-rest) x) (funcall p min x))
      (setf min (car s-rest))
      (setf min-idx idx))))

(defun k-center-heirarchy (S p)
  (multiple-value-bind (S-ordered Rs) (farthest-first S p (length S))
    (format t "Done farthest first~%")
    (let ((Ls '(1))
          (R (first Rs))
          (parents (make-hash-table :test 'equal)))
      (do ((j 1)
           (Rs-rest Rs)
           (SO-rest (rest S-ordered))
           (Lj ())
           (lower-granularity (list (first S-ordered)))) 
          ((null Rs-rest) (progn (push Lj Ls)))
        (if (<= (/ R (expt 2 j)) (first Rs-rest) (/ R (expt 2 (1- j))))
            (progn 
              (push (first SO-rest) Lj)
              (setf (gethash (first SO-rest) parents) (nearest-neighbor
                                                       (first SO-rest)
                                                       lower-granularity p))
              (setf SO-rest (rest SO-rest))
              (setf Rs-rest (rest Rs-rest)))
            (progn
              (push Lj Ls)
              (incf j)
              (setf lower-granularity (append Lj lower-granularity))
              (setf Lj ()))))
      (cons parents S-ordered))))

(defparameter colors (make-array 6 :initial-contents '((178 89 89) (90 160 149)
                                                       (131 202 130) (221 212 129)
                                                       (89 89 178) (89 178 89))))
(defun get-root (pt parents roots)
  (if (gethash pt roots) (gethash pt roots) 
      (get-root (gethash pt parents) parents roots)))
(defun show-n-cluster (ordered-pts parents n)
  (let* ((pad-fact 1.4)
         (min-y (loop for pt in ordered-pts minimizing (second pt)))
         (min-x (loop for pt in ordered-pts minimizing (first pt)))
         (max-y (loop for pt in ordered-pts maximizing (second pt)))
         (max-x (loop for pt in ordered-pts maximizing (first pt)))
         (width (ceiling (* pad-fact (- max-x min-x))))
         (height (ceiling (* pad-fact (- max-y min-y))))
         (o-x (- min-x (* (/ (1- pad-fact) 2) (- max-x min-x))))
         (o-y (+ max-y (* (/ (1- pad-fact) 2) (- max-y min-y))))
         (I (make-8-bit-rgb-image height width ))
         (roots (make-hash-table :test 'equal)))
    (do ((i 0 (1+ i)) (ordered-pts-rst ordered-pts (rest ordered-pts-rst))) ((>= i n))
      (setf (gethash (first ordered-pts-rst) roots) i))
    (format t "Done image pre-calcs~%")
    (fill-image I 255 255 255)
    (horizontal-line I (floor o-y) 0 width 0 0 0)
    (vertical-line I 0 height (floor (- o-x)) 0 0 0)
    (format t "Drawing points...~%~%")
    (loop for pt in ordered-pts
       do (fill-circle* I (floor (- o-y (second pt))) (floor (- (first pt) o-x)) 2
                        (elt colors (get-root pt parents roots))))
    I))
  

(defun make-random-points (n &key (ux 0) (uy 0) (sx 66) (sy 66))
  (loop repeat n collecting (list (+ (rnd-std-normal 15 sx) ux) (+ (rnd-std-normal 15 sy) uy))))
(defun show-points (pts)
  (let* ((pad-fact 1.4)
         (min-y (loop for pt in pts minimizing (second pt)))
         (min-x (loop for pt in pts minimizing (first pt)))
         (max-y (loop for pt in pts maximizing (second pt)))
         (max-x (loop for pt in pts maximizing (first pt)))
         (width (ceiling (* pad-fact (- max-x min-x))))
         (height (ceiling (* pad-fact (- max-y min-y))))
         (o-x (- min-x (* (/ (1- pad-fact) 2) (- max-x min-x))))
         (o-y (+ max-y (* (/ (1- pad-fact) 2) (- max-y min-y))))
         (I (make-8-bit-rgb-image height width )))
    (fill-image I 255 255 255)
    (horizontal-line I (floor o-y) 0 width 0 0 0)
    (vertical-line I 0 height (floor (- o-x)) 0 0 0)
    (loop for pt in pts
       do (fill-circle I (floor (- o-y (second pt))) (floor (- (first pt) o-x)) 2 0 0 0))
    I))

(defun rnd-std-normal (n &optional (scale 1))
  (*  scale (sqrt 12) (- (/ (loop repeat n summing (random 1.0)) (sqrt n)) (* (sqrt n) 0.5))))
(defun mean-point (C)
  (do ((sum (first C))
       (c-rest (rest C) (rest c-rest))) ((null c-rest)
                                         (mapcar (lambda (x) (/ x (length C))) sum))
    (setf sum (mapcar #'+ sum (first c-rest)))))

(defun cost (C z p)
  (do ((c-rest C (rest c-rest))
       (sum 0)) ((null c-rest) sum)
    (incf sum (funcall p z (first c-rest)))))

(defun k-means (S k &optional (init-zs () initialized-centers))
  (let ((zs (if initialized-centers init-zs
                (subseq S 0 (- (length S) k)))))
    (do ((last-cost 1)
         (new-cost 0)) ((= last-cost new-cost) zs)
      (setf last-cost new-cost)
      (setf new-cost 0)
      (let ((C (make-array k :initial-element ())))
        (do ((s-rest S (rest s-rest))) ((null s-rest))
          (multiple-value-bind (center idx) (nearest-neighbor (first s-rest) zs #'p-euclidian)
            (declare (ignore center))
            (push (first s-rest) (elt C idx))))
        (do ((z-rest zs (rest z-rest))
             (i 0 (1+ i))) ((null z-rest))
          (setf (nth i zs) (mean-point (elt C i))))
        (do ((s-rest S (rest s-rest))) ((null s-rest))
          (incf new-cost (p-euclidian (first s-rest)
                                      (nearest-neighbor (first s-rest) zs #'p-euclidian))))))))

(defun pick-with-probs (s ps)
  (setf *random-state* (make-random-state t))
  (let ((val (random 1.0)))
    (do ((p-rest ps (rest p-rest))
         (s-rest s (rest s-rest))
         (sum 0)) ((null (rest p-rest)) (car s-rest))
      (when (>= (+ sum (first p-rest)) val)
        (return (first s-rest)))
      (incf sum (first p-rest)))))

(defun print-return (x)
  (print x)
  x)
(defun make-probs (S Z)
  (do ((ps ())
       (total-cost 0)
       (s-rest S (rest s-rest))) ((null s-rest) (reverse (mapcar 
                                                          (lambda (x) (/ x total-cost)) ps)))
    (let ((cost (p-euclidian (first s-rest)
                             (nearest-neighbor (first s-rest) Z #'p-euclidian))))
      (incf total-cost cost)
      (push cost ps))))

(defun k-means++ (S k)
  (do ((zs (list (nth (random (length S)) S))))
      ((>= (length zs) k) (k-means S k zs))
    (push (pick-with-probs S (make-probs S zs)) zs)))



;;;;;;;;;;;;;;;;;;;;
;; Point Clusters ;;
;;;;;;;;;;;;;;;;;;;;

(defun run-clustering (pts n file)
  (let* ((clustering (k-center-heirarchy pts 'p-euclidian))
         (I (show-n-cluster (cdr clustering) (car clustering) n)))
    (format t "Writing image~%")
    (write-png-file file I)))

(defparameter *pts-4-clusters* (append (make-random-points 100 :ux -150 :uy -150 :sx 33 :sy 33)
                                       (make-random-points 100 :ux -150 :uy 150 :sx 33 :sy 33)
                                       (make-random-points 100 :ux 150 :uy -150 :sx 33 :sy 33)
                                       (make-random-points 100 :ux 150 :uy 150 :sx 33 :sy 33)))


(defparameter *pts-2-4-cluster* (append (make-random-points 100 :ux -150 :uy -75 :sx 33 :sy 33)
                                       (make-random-points 100 :ux -150 :uy 75 :sx 33 :sy 33)
                                       (make-random-points 100 :ux 150 :uy -75 :sx 33 :sy 33)
                                       (make-random-points 100 :ux 150 :uy 75 :sx 33 :sy 33)))

(defparameter *pts-2-close* (append (make-random-points 200 :ux -100 :uy 0 :sx 33 :sy 33)
                                    (make-random-points 200 :ux 100 :uy 0 :sx 33 :sy 33)))

(defparameter *pts-2-closer* (append (make-random-points 200 :ux -70 :uy 0 :sx 33 :sy 33)
                                     (make-random-points 200 :ux 70 :uy 0 :sx 33 :sy 33)))
